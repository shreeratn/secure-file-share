//filepath: requirements.txt
//content:
Django==5.0.2
djangorestframework==3.14.0
djangorestframework-simplejwt==5.3.1
django-cors-headers==4.3.1
pyotp==2.9.0
python-decouple==3.8
pyotp==2.9.0
qrcode==7.4.2


==================================================

//filepath: Dockerfile
//content:
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["sh", "-c", "python manage.py migrate && python manage.py runserver 0.0.0.0:8000"]


==================================================

//filepath: db.sqlite3
//content:
//filepath: db.sqlite3
Error reading file: 'utf-8' codec can't decode byte 0x8b in position 27: invalid start byte

==================================================

//filepath: __init__.py
//content:


==================================================

//filepath: manage.py
//content:
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "core.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


==================================================

//filepath: core/asgi.py
//content:
"""
ASGI config for core project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "core.settings")

application = get_asgi_application()


==================================================

//filepath: core/__init__.py
//content:


==================================================

//filepath: core/settings.py
//content:
"""
Django settings for core project.

Generated by 'django-admin startproject' using Django 4.2.19.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-6ksc&-m#ma5k!bun=_%9m0lsmpmcd3e3c&+r54hy-4tn7h#!m$"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "rest_framework_simplejwt.token_blacklist",
    "authentication",
    "files",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "core.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "core.wsgi.application"


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}

# Custom user model
AUTH_USER_MODEL = 'authentication.User'

# media
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# CORS settings
CORS_ALLOW_ALL_ORIGINS = True  # Only for development
ALLOWED_HOSTS = ['*']  # Only for development


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


==================================================

//filepath: core/urls.py
//content:
"""
URL configuration for core project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path('api/auth/', include('authentication.urls')),
     path('api/files/', include('files.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


==================================================

//filepath: core/wsgi.py
//content:
"""
WSGI config for core project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "core.settings")

application = get_wsgi_application()


==================================================

//filepath: core/__pycache__/settings.cpython-311.pyc
//content:
//filepath: core/__pycache__/settings.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: core/__pycache__/urls.cpython-311.pyc
//content:
//filepath: core/__pycache__/urls.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: core/__pycache__/wsgi.cpython-311.pyc
//content:
//filepath: core/__pycache__/wsgi.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: core/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: core/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/models.py
//content:
from django.db import models
from authentication.models import User

class File(models.Model):
    STATUS_CHOICES = (
        ('private', 'Private'),
        ('public', 'Public'),
    )

    name = models.CharField(max_length=255)
    file = models.FileField(upload_to='uploads/')
    extension = models.CharField(max_length=10)
    size = models.IntegerField()  # in bytes
    uploaded_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='uploaded_files')
    uploaded_date = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='private')
    download_link = models.CharField(max_length=255, null=True, blank=True)
    expiry_date = models.DateTimeField(null=True, blank=True)
    shared_with = models.ManyToManyField(User, related_name='shared_files', blank=True)

class UserStorage(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    used_storage = models.BigIntegerField(default=0)  # in bytes

    @property
    def allocated_storage(self):
        if self.user.user_type == 'admin':
            return 50 * 1024 * 1024 * 1024  # 50GB
        elif self.user.user_type == 'regular':
            return 1 * 1024 * 1024 * 1024   # 1GB
        return 500 * 1024 * 1024            # 500MB for guest

class RoleUpgradeRequest(models.Model):
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
    )

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='role_requests')
    requested_role = models.CharField(max_length=10)
    current_role = models.CharField(max_length=10)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending')
    request_date = models.DateTimeField(auto_now_add=True)


==================================================

//filepath: files/serializers.py
//content:
from rest_framework import serializers
from .models import File, UserStorage, RoleUpgradeRequest
from datetime import timedelta, datetime, timezone


class FileSerializer(serializers.ModelSerializer):
    uploaded_by = serializers.SerializerMethodField()

    class Meta:
        model = File
        fields = ['id', 'name', 'size', 'extension', 'status', 'expiry_date', 'uploaded_date', 'download_link', 'uploaded_by']

    def get_uploaded_by(self, obj):
        return {
            'id': obj.uploaded_by.id,
            'name': obj.uploaded_by.first_name,
            'email': obj.uploaded_by.email
        }

class UserStorageSerializer(serializers.ModelSerializer):
    allocated_storage = serializers.ReadOnlyField()

    class Meta:
        model = UserStorage
        fields = ['used_storage', 'allocated_storage']

class FileUploadSerializer(serializers.ModelSerializer):
    file = serializers.FileField()
    expiry_days = serializers.IntegerField(min_value=1, max_value=30, default=7)

    class Meta:
        model = File
        fields = ['file', 'status', 'expiry_days']

    def create(self, validated_data):
        # Remove expiry_days from validated_data as it's not a model field
        expiry_days = validated_data.pop('expiry_days', 7)
        file_obj = validated_data.pop('file')

        # Create the file instance
        file_instance = File.objects.create(
            name=file_obj.name,
            file=file_obj,
            extension=file_obj.name.split('.')[-1],
            size=file_obj.size,
            uploaded_by=self.context['request'].user,
            status=validated_data.get('status', 'private'),
            expiry_date=datetime.now(timezone.utc) + timedelta(days=expiry_days)
        )

        return file_instance


class RoleUpgradeRequestSerializer(serializers.ModelSerializer):
    user_name = serializers.SerializerMethodField(method_name='get_user_name')
    user_email = serializers.SerializerMethodField(method_name='get_user_email')
    user_id = serializers.SerializerMethodField(method_name='get_user_id')

    class Meta:
        model = RoleUpgradeRequest
        fields = ['id', 'user_id', 'user_name', 'user_email', 'current_role', 'requested_role', 'status', 'request_date']

    def get_user_name(self, obj):
        return obj.user.get_full_name()

    def get_user_email(self, obj):
        return obj.user.email

    def get_user_id(self, obj):
        return obj.user.id


==================================================

//filepath: files/__init__.py
//content:


==================================================

//filepath: files/apps.py
//content:
from django.apps import AppConfig


class FilesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "files"


==================================================

//filepath: files/admin.py
//content:
from django.contrib import admin

# Register your models here.


==================================================

//filepath: files/tests.py
//content:
from django.test import TestCase

# Create your tests here.


==================================================

//filepath: files/urls.py
//content:
from django.urls import path
from . import views

urlpatterns = [
    path('user-data/', views.get_user_data, name='user-data'),
    path('uploaded-files/', views.get_uploaded_files, name='uploaded-files'),
    path('shared-files/', views.get_shared_files, name='shared-files'),
    path('upload/', views.upload_file, name='upload-file'),
    path('delete/<int:file_id>/', views.delete_file, name='delete-file'),
    path('share/<int:file_id>/', views.share_file, name='share-file'),
    path('download/<str:download_link>/', views.download_file, name='download-file'),

    #role requests
    path('role-requests/', views.get_role_requests, name='role-requests'),
    path('request-upgrade/', views.request_role_upgrade, name='request-upgrade'),
    path('approve-upgrade/<int:user_id>/', views.approve_role_upgrade, name='approve-upgrade'),
    path('downgrade-to-guest/<int:user_id>/', views.downgrade_to_guest, name='downgrade-to-guest'),
]


==================================================

//filepath: files/views.py
//content:
from django.http import FileResponse
from rest_framework import viewsets, status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from datetime import datetime, timedelta, timezone
import uuid
from authentication.models import User  # Add this import
from .models import File, UserStorage, RoleUpgradeRequest
from .serializers import FileSerializer, UserStorageSerializer, FileUploadSerializer, RoleUpgradeRequestSerializer


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_user_data(request):
    user = request.user
    storage = UserStorage.objects.get_or_create(user=user)[0]

    data = {
        'name': user.first_name,
        'total_files_shared': File.objects.filter(uploaded_by=user).count(),
        'used_storage': storage.used_storage,
        'allocated_storage': storage.allocated_storage,
        'current_role': user.user_type,
    }

    if user.user_type == 'admin':
        data.update({
            'incomplete_mfa': User.objects.filter(is_mfa_enabled=False).count(),
            'encryption_health': 100,  # Placeholder
            'failed_decryption_alerts': 0  # Placeholder
        })

    return Response(data)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_uploaded_files(request):
    files = File.objects.filter(uploaded_by=request.user)
    serializer = FileSerializer(files, many=True)
    return Response(serializer.data)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_shared_files(request):
    files = File.objects.filter(shared_with=request.user).select_related('uploaded_by')
    serializer = FileSerializer(files, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def upload_file(request):
    # Check if user is guest
    if request.user.user_type == User.UserType.GUEST:
        return Response({
            'error': 'Guests cannot upload files'
        }, status=status.HTTP_403_FORBIDDEN)

    serializer = FileUploadSerializer(data=request.data, context={'request': request})
    if serializer.is_valid():
        file = request.FILES['file']

        # Set max file size based on user type (10MB for admin, 5MB for regular)
        max_size = 10485760 if request.user.user_type == User.UserType.ADMIN else 5242880
        if file.size > max_size:
            return Response({
                'error': f'File size exceeds limit. Maximum size allowed is {max_size/1048576}MB'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Check user's storage limit
        storage = UserStorage.objects.get_or_create(user=request.user)[0]
        if storage.used_storage + file.size > storage.allocated_storage:
            return Response({
                'error': 'Storage limit exceeded'
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
        # Create file record
            new_file = File.objects.create(
                name=file.name,
                file=file,
                extension=file.name.split('.')[-1],
                size=file.size,
                uploaded_by=request.user,
                status=serializer.validated_data.get('status', 'private'),
                expiry_date=datetime.now(timezone.utc) + timedelta(days=serializer.validated_data.get('expiry_days', 7)),
                download_link=str(uuid.uuid4())  # Generate download link for all files
            )

            # Update user's storage usage
            storage.used_storage += file.size
            storage.save()

            return Response(
                FileSerializer(new_file).data,
                status=status.HTTP_201_CREATED
            )


        except Exception as e:
            return Response({
                'error': f'Error uploading file: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    return Response(
        serializer.errors,
        status=status.HTTP_400_BAD_REQUEST
    )

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_file(request, file_id):
    try:
        file = File.objects.get(id=file_id, uploaded_by=request.user)
        file_size = file.size
        file.delete()

        # Update user's storage usage
        storage = UserStorage.objects.get(user=request.user)
        storage.used_storage -= file_size
        storage.save()

        return Response({'message': 'File deleted successfully'})
    except File.DoesNotExist:
        return Response({'error': 'File not found'}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def share_file(request, file_id):
    try:
        file = File.objects.get(id=file_id, uploaded_by=request.user)
        emails = request.data.get('emails', [])

        for email in emails:
            try:
                user = User.objects.get(email=email)
                file.shared_with.add(user)
            except User.DoesNotExist:
                pass

        file.status = 'public'
        file.download_link = str(uuid.uuid4())
        file.save()

        return Response(FileSerializer(file).data)
    except File.DoesNotExist:
        return Response({'error': 'File not found'}, status=status.HTTP_404_NOT_FOUND)

from django.http import FileResponse
import mimetypes

@api_view(['GET'])
def download_file(request, download_link):
    try:
        file = File.objects.get(download_link=download_link)

        # Check expiry
        if file.expiry_date and file.expiry_date < datetime.now(timezone.utc):
            return Response({'error': 'File has expired'}, status=status.HTTP_410_GONE)

        # Get file path and determine content type
        file_path = file.file.path
        content_type, _ = mimetypes.guess_type(file_path)
        if not content_type:
            content_type = 'application/octet-stream'

        # Create response
        response = FileResponse(open(file_path, 'rb'), content_type=content_type)
        response['Content-Disposition'] = f'attachment; filename="{file.name}"'

        return response

    except File.DoesNotExist:
        return Response({'error': 'File not found'}, status=status.HTTP_404_NOT_FOUND)



# Role requests
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_role_requests(request):
    # Only admins can view role requests
    if request.user.user_type != User.UserType.ADMIN:
        return Response({'error': 'Unauthorized'}, status=status.HTTP_403_FORBIDDEN)

    requests = RoleUpgradeRequest.objects.filter(status='pending')
    serializer = RoleUpgradeRequestSerializer(requests, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def request_role_upgrade(request):
    current_role = request.user.user_type

    # Determine next role
    if current_role == User.UserType.GUEST:
        requested_role = User.UserType.REGULAR
    elif current_role == User.UserType.REGULAR:
        requested_role = User.UserType.ADMIN
    else:
        return Response({'error': 'Already at highest role'}, status=status.HTTP_400_BAD_REQUEST)

    # Check for existing pending request
    existing_request = RoleUpgradeRequest.objects.filter(
        user=request.user,
        status='pending'
    ).exists()

    if existing_request:
        return Response({'error': 'Pending request already exists'}, status=status.HTTP_400_BAD_REQUEST)

    # Create new request
    RoleUpgradeRequest.objects.create(
        user=request.user,
        current_role=current_role,
        requested_role=requested_role
    )

    return Response({'message': f'Upgrade request to {requested_role} submitted successfully'})

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def approve_role_upgrade(request, user_id):
    if request.user.user_type != User.UserType.ADMIN:
        return Response({'error': 'Unauthorized'}, status=status.HTTP_403_FORBIDDEN)

    try:
        role_request = RoleUpgradeRequest.objects.get(
            user_id=user_id,
            status='pending'
        )

        # Update user's role
        user = role_request.user
        user.user_type = role_request.requested_role
        user.save()

        # Update request status
        role_request.status = 'approved'
        role_request.save()

        return Response({'message': 'Role upgrade approved successfully'})
    except RoleUpgradeRequest.DoesNotExist:
        return Response({'error': 'Request not found'}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def downgrade_to_guest(request, user_id):
    if request.user.user_type != User.UserType.ADMIN:
        return Response({'error': 'Unauthorized'}, status=status.HTTP_403_FORBIDDEN)

    try:
        user = User.objects.get(id=user_id)
        if user.user_type == User.UserType.ADMIN:
            return Response({'error': 'Cannot downgrade admin users'}, status=status.HTTP_400_BAD_REQUEST)

        user.user_type = User.UserType.GUEST
        user.save()

        # Cancel any pending upgrade requests
        RoleUpgradeRequest.objects.filter(user=user, status='pending').update(status='rejected')

        return Response({'message': 'User downgraded to guest successfully'})
    except User.DoesNotExist:
        return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)


==================================================

//filepath: files/migrations/0002_roleupgraderequest.py
//content:
# Generated by Django 4.2.19 on 2025-02-15 17:04

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ("files", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="RoleUpgradeRequest",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("requested_role", models.CharField(max_length=10)),
                ("current_role", models.CharField(max_length=10)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("approved", "Approved"),
                            ("rejected", "Rejected"),
                        ],
                        default="pending",
                        max_length=10,
                    ),
                ),
                ("request_date", models.DateTimeField(auto_now_add=True)),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="role_requests",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
    ]


==================================================

//filepath: files/migrations/__init__.py
//content:


==================================================

//filepath: files/migrations/0001_initial.py
//content:
# Generated by Django 4.2.19 on 2025-02-14 13:15

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="UserStorage",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("used_storage", models.BigIntegerField(default=0)),
                (
                    "user",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="File",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=255)),
                ("file", models.FileField(upload_to="uploads/")),
                ("extension", models.CharField(max_length=10)),
                ("size", models.IntegerField()),
                ("uploaded_date", models.DateTimeField(auto_now_add=True)),
                (
                    "status",
                    models.CharField(
                        choices=[("private", "Private"), ("public", "Public")],
                        default="private",
                        max_length=10,
                    ),
                ),
                (
                    "download_link",
                    models.CharField(blank=True, max_length=255, null=True),
                ),
                ("expiry_date", models.DateTimeField(blank=True, null=True)),
                (
                    "shared_with",
                    models.ManyToManyField(
                        blank=True,
                        related_name="shared_files",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
                (
                    "uploaded_by",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="uploaded_files",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
    ]


==================================================

//filepath: files/migrations/__pycache__/0001_initial.cpython-311.pyc
//content:
//filepath: files/migrations/__pycache__/0001_initial.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/migrations/__pycache__/0002_roleupgraderequest.cpython-311.pyc
//content:
//filepath: files/migrations/__pycache__/0002_roleupgraderequest.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/migrations/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: files/migrations/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/views.cpython-311.pyc
//content:
//filepath: files/__pycache__/views.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/urls.cpython-311.pyc
//content:
//filepath: files/__pycache__/urls.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/models.cpython-311.pyc
//content:
//filepath: files/__pycache__/models.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/serializers.cpython-311.pyc
//content:
//filepath: files/__pycache__/serializers.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/admin.cpython-311.pyc
//content:
//filepath: files/__pycache__/admin.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/apps.cpython-311.pyc
//content:
//filepath: files/__pycache__/apps.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: files/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: files/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/models.py
//content:
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    class UserType(models.TextChoices):
        GUEST = 'guest', 'Guest'
        REGULAR = 'regular', 'Regular'
        ADMIN = 'admin', 'Admin'

    email = models.EmailField(unique=True)
    is_mfa_enabled = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    mfa_secret = models.CharField(max_length=32, blank=True, null=True)
    user_type = models.CharField(
        max_length=10,
        choices=UserType.choices,
        default=UserType.GUEST
    )


    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']


==================================================

//filepath: authentication/serializers.py
//content:
from datetime import timedelta, datetime, timezone
from rest_framework import serializers
from .models import User
import re
from django.core.validators import EmailValidator


class UserRegistrationSerializer(serializers.ModelSerializer):
    name = serializers.CharField()  # Add this field
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('id', 'email', 'password', 'name', 'is_mfa_enabled', 'user_type')
        read_only_fields = ('user_type',)

    def validate_email(self, value):
        email_validator = EmailValidator()
        try:
            email_validator(value)
        except:
            raise serializers.ValidationError("Invalid email format")
        return value

    def validate_password(self, value):
        if len(value) < 6 or len(value) > 18:
            raise serializers.ValidationError("Password must be between 6-18 characters")
        if not re.search(r'[A-Z]', value):
            raise serializers.ValidationError("Password must contain at least one uppercase letter")
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
            raise serializers.ValidationError("Password must contain at least one special character")
        if not re.search(r'\d', value):
            raise serializers.ValidationError("Password must contain at least one digit")
        return value

    def create(self, validated_data):
        name = validated_data.pop('name')  # Get the name field
        validated_data['first_name'] = name  # Store the name in first_name
        validated_data['last_name'] = ''  # Empty last_name
        validated_data['user_type'] = User.UserType.GUEST
        validated_data['username'] = validated_data['email']
        user = User.objects.create_user(**validated_data)
        return user

class LoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField()


class MFASerializer(serializers.Serializer):
    code = serializers.CharField()


class UserListSerializer(serializers.ModelSerializer):
    name = serializers.CharField(source='first_name')
    member_since = serializers.DateTimeField(source='created_at')

    class Meta:
        model = User
        fields = ('id', 'name', 'email', 'user_type', 'is_mfa_enabled', 'member_since')

class UserRoleUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('user_type',)

    def validate_user_type(self, value):
        if value not in [User.UserType.GUEST, User.UserType.REGULAR, User.UserType.ADMIN]:
            raise serializers.ValidationError("Invalid user type")
        return value

class MFAPendingUserSerializer(serializers.ModelSerializer):
    name = serializers.CharField(source='first_name')
    user_since = serializers.DateTimeField(source='date_joined')
    days_left = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = ('id', 'name', 'email', 'user_since', 'days_left')

    def get_days_left(self, obj):
        joined_date = obj.date_joined
        deadline = joined_date + timedelta(days=7)
        days_left = (deadline - datetime.now(timezone.utc)).days
        return max(0, days_left)


==================================================

//filepath: authentication/__init__.py
//content:


==================================================

//filepath: authentication/urls.py
//content:
from django.urls import path
from . import views

urlpatterns = [
    path("register/", views.register, name="register"),
    path("login/", views.login, name="login"),
    path("verify-mfa/", views.verify_mfa, name="verify-mfa"),
    path("logout/", views.logout, name="logout"),
    path("mfa/setup/", views.setup_mfa, name="mfa-setup"),
    path("mfa/verify/", views.verify_mfa_setup, name="mfa-verify"),
    path("users/", views.get_all_users, name="get-all-users"),
    path("users/<int:user_id>/role/", views.update_user_role, name="update-user-role"),
    path("mfa-pending/", views.get_mfa_pending_users, name="mfa-pending")
]


==================================================

//filepath: authentication/views.py
//content:
from django.contrib.auth import authenticate
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
import pyotp
from django.utils import timezone
from datetime import timedelta
from .serializers import UserRegistrationSerializer, LoginSerializer, MFASerializer, MFAPendingUserSerializer
from .models import User


@api_view(["POST"])
def register(request):
    serializer = UserRegistrationSerializer(data=request.data)
    if serializer.is_valid():
        user = serializer.save()
        refresh = RefreshToken.for_user(user)
        return Response(
            {
                "message": "User registered successfully",
                "user_id": user.id,
                "token": str(refresh.access_token),
                "refresh_token": str(refresh),
                "isMFAenabled": user.is_mfa_enabled,
            },
            status=status.HTTP_201_CREATED,
        )
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(["POST"])
def login(request):
    serializer = LoginSerializer(data=request.data)
    if serializer.is_valid():
        user = authenticate(
            username=serializer.validated_data["email"],
            password=serializer.validated_data["password"],
        )
        if user:
            refresh = RefreshToken.for_user(user)
            return Response(
                {
                    "token": str(refresh.access_token),
                    "refresh_token": str(refresh),
                    "isMFAenabled": user.is_mfa_enabled,
                }
            )
        return Response(
            {"error": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED
        )
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(["POST"])
def verify_mfa(request):
    serializer = MFASerializer(data=request.data)
    if serializer.is_valid():
        # Implement MFA verification logic here
        return Response({"message": "MFA verified successfully"})
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def logout(request):
    try:
        refresh_token = request.data["refresh_token"]
        token = RefreshToken(refresh_token)
        token.blacklist()
        return Response({"message": "Successfully logged out"})
    except Exception:
        return Response({"error": "Invalid token"}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout(request):
    try:
        refresh_token = request.data.get('refresh_token')
        if refresh_token:
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response({
                "message": "Successfully logged out",
                "status": "success"
            }, status=status.HTTP_200_OK)
        else:
            return Response({
                "message": "Refresh token is required",
                "status": "error"
            }, status=status.HTTP_400_BAD_REQUEST)
    except TokenError:
        return Response({
            "message": "Invalid token",
            "status": "error"
        }, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def setup_mfa(request):
    user = request.user
    secret = pyotp.random_base32()
    user.mfa_secret = secret
    user.save()

    totp = pyotp.TOTP(secret)
    provisioning_uri = totp.provisioning_uri(
        user.email,
        issuer_name="SecureFileShare"
    )

    return Response({
        'qr_code': provisioning_uri,
        'secret': secret
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def verify_mfa_setup(request):
    otp = request.data.get('otp')
    user = request.user

    if not otp or not user.mfa_secret:
        return Response({
            'message': 'Invalid OTP or MFA not set up',
            'success': False
        }, status=status.HTTP_400_BAD_REQUEST)

    # Add tolerance window for TOTP verification
    totp = pyotp.TOTP(user.mfa_secret)
    if totp.verify(otp, valid_window=3):  # Allow 1 window before/after
        user.is_mfa_enabled = True
        user.save()
        refresh = RefreshToken.for_user(user)
        return Response({
            'message': 'MFA enabled successfully',
            'success': True,
            'token': str(refresh.access_token),
            'refresh_token': str(refresh),
            'isMFAenabled': user.is_mfa_enabled
        })

    return Response({
        'message': 'Invalid OTP',
        'success': False
    }, status=status.HTTP_400_BAD_REQUEST)

# authentications/views.py
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_all_users(request):
    # Check if user is admin
    if request.user.user_type != User.UserType.ADMIN:
        return Response({
            "error": "Only admin users can access this endpoint"
        }, status=status.HTTP_403_FORBIDDEN)

    users = User.objects.all().order_by('-created_at')
    serializer = UserListSerializer(users, many=True)
    return Response(serializer.data)

@api_view(['PATCH'])
@permission_classes([IsAuthenticated])
def update_user_role(request, user_id):
    # Check if user is admin
    if request.user.user_type != User.UserType.ADMIN:
        return Response({
            "error": "Only admin users can access this endpoint"
        }, status=status.HTTP_403_FORBIDDEN)

    try:
        user = User.objects.get(id=user_id)
    except User.DoesNotExist:
        return Response({
            "error": "User not found"
        }, status=status.HTTP_404_NOT_FOUND)

    serializer = UserRoleUpdateSerializer(user, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response({
            "message": "User role updated successfully",
            "user": UserListSerializer(user).data
        })
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_mfa_pending_users(request):
    if request.user.user_type != User.UserType.ADMIN:
        return Response({
            "error": "Only admin users can access this endpoint"
        }, status=status.HTTP_403_FORBIDDEN)

    users = User.objects.filter(
        is_mfa_enabled=False,
        date_joined__gte=timezone.now() - timedelta(days=7)
    ).order_by('date_joined')

    serializer = MFAPendingUserSerializer(users, many=True)
    return Response(serializer.data)


==================================================

//filepath: authentication/migrations/0003_user_created_at.py
//content:
# Generated by Django 4.2.19 on 2025-02-14 13:56

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):
    dependencies = [
        ("authentication", "0002_user_user_type"),
    ]

    operations = [
        migrations.AddField(
            model_name="user",
            name="created_at",
            field=models.DateTimeField(
                auto_now_add=True, default=django.utils.timezone.now
            ),
            preserve_default=False,
        ),
    ]


==================================================

//filepath: authentication/migrations/0002_user_user_type.py
//content:
# Generated by Django 5.0.2 on 2025-02-13 12:24

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('authentication', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='user_type',
            field=models.CharField(choices=[('guest', 'Guest'), ('regular', 'Regular'), ('admin', 'Admin')], default='guest', max_length=10),
        ),
    ]


==================================================

//filepath: authentication/migrations/__init__.py
//content:


==================================================

//filepath: authentication/migrations/0001_initial.py
//content:
# Generated by Django 5.0.2 on 2025-02-13 11:46

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('is_mfa_enabled', models.BooleanField(default=False)),
                ('mfa_secret', models.CharField(blank=True, max_length=32, null=True)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


==================================================

//filepath: authentication/migrations/__pycache__/0003_user_created_at.cpython-311.pyc
//content:
//filepath: authentication/migrations/__pycache__/0003_user_created_at.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/migrations/__pycache__/0001_initial.cpython-311.pyc
//content:
//filepath: authentication/migrations/__pycache__/0001_initial.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/migrations/__pycache__/0002_user_user_type.cpython-311.pyc
//content:
//filepath: authentication/migrations/__pycache__/0002_user_user_type.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/migrations/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: authentication/migrations/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/management/__init__.py
//content:


==================================================

//filepath: authentication/management/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: authentication/management/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/management/commands/__init__.py
//content:


==================================================

//filepath: authentication/management/commands/create_admin.py
//content:
from django.core.management.base import BaseCommand
from authentication.models import User

class Command(BaseCommand):
    help = 'Creates an admin user'

    def handle(self, *args, **options):
        if not User.objects.filter(email='adminx@example.com').exists():
            User.objects.create_user(
                username='adminx@example.com',
                email='adminx@example.com',
                password='adminx@example.com',
                first_name='Admin',
                user_type='admin',
                is_staff=True,
                is_superuser=True
            )
            self.stdout.write(self.style.SUCCESS('Admin user created successfully'))
        else:
            self.stdout.write(self.style.WARNING('Admin user already exists'))


==================================================

//filepath: authentication/__pycache__/views.cpython-311.pyc
//content:
//filepath: authentication/__pycache__/views.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/__pycache__/urls.cpython-311.pyc
//content:
//filepath: authentication/__pycache__/urls.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/__pycache__/models.cpython-311.pyc
//content:
//filepath: authentication/__pycache__/models.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/__pycache__/serializers.cpython-311.pyc
//content:
//filepath: authentication/__pycache__/serializers.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: authentication/__pycache__/__init__.cpython-311.pyc
//content:
//filepath: authentication/__pycache__/__init__.cpython-311.pyc
Error reading file: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte

==================================================

//filepath: media/uploads/Frontend_Sys_Design_U6J3ZBy.png
//content:
//filepath: media/uploads/Frontend_Sys_Design_U6J3ZBy.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/ACK514237790170723.pdf
//content:
//filepath: media/uploads/ACK514237790170723.pdf
Error reading file: 'utf-8' codec can't decode byte 0xac in position 0: invalid start byte

==================================================

//filepath: media/uploads/E030JCUSR5G-U03S336Q4EM-4d52c67ebcd4-512.png
//content:
//filepath: media/uploads/E030JCUSR5G-U03S336Q4EM-4d52c67ebcd4-512.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/supermanlogo.png
//content:
//filepath: media/uploads/supermanlogo.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30.jpg
//content:
//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30.jpg
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

==================================================

//filepath: media/uploads/GainsightLogo.png
//content:
//filepath: media/uploads/GainsightLogo.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/Frontend_Sys_Design_8XLfhyB.png
//content:
//filepath: media/uploads/Frontend_Sys_Design_8XLfhyB.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/Frontend_Sys_Design.png
//content:
//filepath: media/uploads/Frontend_Sys_Design.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_8uoWyEr.jpg
//content:
//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_8uoWyEr.jpg
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

==================================================

//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_3iISvxu.jpg
//content:
//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_3iISvxu.jpg
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

==================================================

//filepath: media/uploads/WhatsApp_Image_2024-12-06_at_14.46.39.jpeg
//content:
//filepath: media/uploads/WhatsApp_Image_2024-12-06_at_14.46.39.jpeg
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

==================================================

//filepath: media/uploads/Frontend_Sys_Design_dfdgzEX.png
//content:
//filepath: media/uploads/Frontend_Sys_Design_dfdgzEX.png
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte

==================================================

//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_Hs8PPUG.jpg
//content:
//filepath: media/uploads/tim-goedhart-vnpTRdmtQ30_Hs8PPUG.jpg
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

==================================================

